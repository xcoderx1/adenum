<#
.SYNOPSIS
    Ultimate AD Enumeration & Security Audit (PowerShell Edition)

.DESCRIPTION
    PowerShell port inspired by ultimate_ad_enum.sh and modules/*.
    - 14 phases covering LDAP, Kerberos, ADCS, Delegation, GPO, ACLs, Shares,
      Credentials, Sessions, Trusts, Infra, BloodHound prep, Security controls,
      and LOLBins/persistence indicators.
    - Focused on defensive auditing (no exploit / hash-cracking automation).

.NOTES
    Run from a domain-joined Windows host with RSAT AD tools if possible.
#>

[CmdletBinding()]
param(
    [string]$Domain,
    [string]$DcIP,
    [string]$DnsServer,
    [string]$Username,
    [string]$Password,
    [string]$OutputDir = $(Join-Path -Path (Get-Location) -ChildPath ("AD_Enum_{0:yyyyMMdd_HHmmss}" -f (Get-Date))),
    [switch]$Quick,
    [switch]$NonInteractive,
    [switch]$Help,
    [switch]$Version
)

#region Global State / Variables

$Script:VERSION              = '1.1.0-ULTIMATE-PS'
$Script:StartTime            = Get-Date
$Script:TotalChecks          = 0
$Script:SuccessfulChecks     = 0
$Script:FailedChecks         = 0

$Script:CriticalFindings     = 0
$Script:HighFindings         = 0
$Script:MediumFindings       = 0
$Script:InfoFindings         = 0

$Script:Findings             = New-Object System.Collections.Generic.List[object]
$Script:AuthType             = $null      # 'UserPass' | 'Anonymous' | 'Kerberos'
$Script:Credential           = $null
$Script:QuickMode            = [bool]$Quick
$Script:OutputRoot           = $OutputDir

$Script:DomainName           = $Domain
$Script:DcAddress            = $DcIP
$Script:DnsServerAddress     = $DnsServer
$Script:UserName             = $Username
$Script:PlainPassword        = $Password
$Script:BaseDN               = $null
$Script:DomainObject         = $null

#endregion Global State

#region UI / Logging helpers

function Show-Banner {
    Clear-Host
    Write-Host "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Cyan
    Write-Host "‚ïë   üéØ ULTIMATE AD ENUM & SECURITY AUDIT (PowerShell Edition)         ‚ïë" -ForegroundColor Cyan
    Write-Host "‚ïë   Coverage: LDAP, Kerberos, ADCS, Delegation, GPO, ACL, Shares,     ‚ïë" -ForegroundColor Cyan
    Write-Host "‚ïë             Credentials, Sessions, Trusts, Infra & more             ‚ïë" -ForegroundColor Cyan
    Write-Host "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Cyan
    Write-Host ""
    Write-Host ("Version: {0}" -f $Script:VERSION) -ForegroundColor DarkCyan
    Write-Host ""
}

function Write-Info {
    param([string]$Message)
    Write-Host "[*] $Message" -ForegroundColor Cyan
}

function Write-Action {
    param([string]$Message)
    Write-Host "[>] $Message" -ForegroundColor White
}

function Write-Success {
    param([string]$Message)
    Write-Host "[+] $Message" -ForegroundColor Green
}

function Write-WarningMsg {
    param([string]$Message)
    Write-Host "[!] $Message" -ForegroundColor Yellow
}

function Write-ErrorMsg {
    param([string]$Message)
    Write-Host "[X] $Message" -ForegroundColor Red
}

function Write-Section {
    param([string]$Title)
    Write-Host ""
    Write-Host "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" -ForegroundColor DarkCyan
    Write-Host "  $Title" -ForegroundColor DarkCyan
    Write-Host "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" -ForegroundColor DarkCyan
    Write-Host ""
}

#endregion UI / Logging

#region Findings

function Add-Finding {
    param(
        [ValidateSet('CRITICAL', 'HIGH', 'MEDIUM', 'INFO')]
        [string]$Level,
        [string]$Category,
        [string]$Message,
        [string]$Recommendation = ''
    )

    switch ($Level) {
        'CRITICAL' { $Script:CriticalFindings++ ; $fg = 'Red' }
        'HIGH'     { $Script:HighFindings++     ; $fg = 'Yellow' }
        'MEDIUM'   { $Script:MediumFindings++   ; $fg = 'Magenta' }
        'INFO'     { $Script:InfoFindings++     ; $fg = 'Gray' }
    }

    $obj = [PSCustomObject]@{
        Timestamp      = Get-Date
        Level          = $Level
        Category       = $Category
        Message        = $Message
        Recommendation = $Recommendation
    }

    $Script:Findings.Add($obj) | Out-Null
    Write-Host ("[{0}] {1}: {2}" -f $Level, $Category, $Message) -ForegroundColor $fg
}

#endregion Findings

#region Prompt Helpers

function Prompt-Input {
    param(
        [string]$Prompt,
        [string]$Default,
        [string]$CurrentValue
    )

    if ($Script:NonInteractive -and $CurrentValue) {
        return $CurrentValue
    }

    if ($Default) {
        $answer = Read-Host ("$Prompt [$Default]")
        if ([string]::IsNullOrWhiteSpace($answer)) { return $Default }
        return $answer
    } else {
        $answer = Read-Host $Prompt
        return $answer
    }
}

function Prompt-YesNo {
    param(
        [string]$Prompt,
        [bool]$Default = $true
    )

    if ($Script:NonInteractive) {
        return $Default
    }

    while ($true) {
        if ($Default) {
            $answer = Read-Host ("$Prompt [Y/n]")
            if ([string]::IsNullOrWhiteSpace($answer)) { return $true }
        } else {
            $answer = Read-Host ("$Prompt [y/N]")
            if ([string]::IsNullOrWhiteSpace($answer)) { return $false }
        }

        switch -Regex ($answer) {
            '^(y|yes)$' { return $true }
            '^(n|no)$'  { return $false }
            default     { Write-WarningMsg "Please answer yes or no." }
        }
    }
}

#endregion Prompt Helpers

#region Configuration

function Show-Help {
@"
Usage: .\Ultimate-ADEnum.ps1 [options]

Options:
    -Domain        <string>  AD domain name (e.g. contoso.local)
    -DcIP          <string>  Domain Controller IP or hostname
    -DnsServer     <string>  DNS server to use (optional)
    -Username      <string>  Domain user (e.g. CONTOSO\user or user@contoso.local)
    -Password      <string>  Password (plain text; or omit to be prompted)
    -OutputDir     <string>  Output directory (default: .\AD_Enum_yyyyMMdd_HHmmss)
    -Quick                   Quick mode (skip some slower checks)
    -NonInteractive          Do not prompt; rely on provided parameters
    -Help                    Show this help
    -Version                 Show version
"@ | Write-Host
}

function Configure-Authentication {
    if ($Script:NonInteractive) {
        if ($Script:UserName -and $Script:PlainPassword) {
            $Script:AuthType = 'UserPass'
        } elseif ($Script:UserName -and -not $Script:PlainPassword) {
            $Script:AuthType = 'Kerberos'
        } else {
            $Script:AuthType = 'Anonymous'
        }
    }
    else {
        Write-Section "Authentication"
        Write-Host "Select authentication method:" -ForegroundColor Cyan
        Write-Host "  [1] Username + Password" -ForegroundColor White
        Write-Host "  [2] Anonymous (limited)" -ForegroundColor White
        Write-Host "  [3] Kerberos (current logon)" -ForegroundColor White
        Write-Host ""

        while (-not $Script:AuthType) {
            $choice = Read-Host "Choice (1/2/3)"
            switch ($choice) {
                '1' {
                    $Script:UserName = Prompt-Input -Prompt "Username (DOMAIN\user or user@domain)" -Default $Script:UserName -CurrentValue $Script:UserName
                    if (-not $Script:PlainPassword) {
                        $sec = Read-Host "Password" -AsSecureString
                        $Script:PlainPassword = [Runtime.InteropServices.Marshal]::PtrToStringUni(
                            [Runtime.InteropServices.Marshal]::SecureStringToBSTR($sec)
                        )
                    }
                    $Script:AuthType = 'UserPass'
                }
                '2' {
                    Write-WarningMsg "Anonymous bind will provide limited information."
                    $Script:AuthType = 'Anonymous'
                }
                '3' {
                    Write-Info "Using current logon / Kerberos credential."
                    $Script:AuthType = 'Kerberos'
                }
                default {
                    Write-ErrorMsg "Invalid choice. Select 1, 2, or 3."
                }
            }
        }
    }

    if ($Script:AuthType -eq 'UserPass' -and $Script:UserName -and $Script:PlainPassword) {
        try {
            $secure = ConvertTo-SecureString $Script:PlainPassword -AsPlainText -Force
            $Script:Credential = New-Object System.Management.Automation.PSCredential ($Script:UserName, $secure)
            Write-Success "Credential object created."
        } catch {
            Write-ErrorMsg "Failed to create PSCredential: $_"
        }
    } elseif ($Script:AuthType -eq 'Kerberos') {
        Write-Info "Using current user context for domain operations."
    } else {
        Write-Info "No credential will be used where optional."
    }
}

function Configure-Scope {
    Write-Section "Scope Configuration"

    $Script:DomainName = Prompt-Input -Prompt "Domain (e.g. contoso.local)" -Default $Script:DomainName -CurrentValue $Script:DomainName
    $Script:DcAddress  = Prompt-Input -Prompt "Domain Controller (IP/hostname)" -Default $Script:DcAddress -CurrentValue $Script:DcAddress
    $Script:DnsServerAddress = Prompt-Input -Prompt "DNS Server (leave blank to use system default)" -Default $Script:DnsServerAddress -CurrentValue $Script:DnsServerAddress

    Write-Info "Domain        : $($Script:DomainName)"
    Write-Info "DC            : $($Script:DcAddress)"
    if ($Script:DnsServerAddress) {
        Write-Info "DNS           : $($Script:DnsServerAddress)"
    }
    Write-Info ("Mode          : {0}" -f ($(if ($Script:QuickMode) { "Quick" } else { "Full" })))
}

function Initialize-Output {
    Write-Section "Output Preparation"

    if (-not (Test-Path $Script:OutputRoot)) {
        New-Item -ItemType Directory -Path $Script:OutputRoot -Force | Out-Null
    }

    foreach ($d in @('ldap','kerberos','adcs','delegation','gpo','acl','shares','credentials','sessions','trusts','infrastructure','bloodhound','reports','security','persistence')) {
        $full = Join-Path $Script:OutputRoot $d
        if (-not (Test-Path $full)) {
            New-Item -ItemType Directory -Path $full -Force | Out-Null
        }
    }

    Write-Success "Output directory: $($Script:OutputRoot)"
}

function Check-Dependencies {
    Write-Section "Dependency Check (PowerShell)"

    # ActiveDirectory module
    try {
        Import-Module ActiveDirectory -ErrorAction Stop
        Write-Success "ActiveDirectory module loaded."
    } catch {
        Write-WarningMsg "ActiveDirectory module NOT found. Many AD checks will be skipped."
    }

    # GroupPolicy module (for GPO checks)
    try {
        Import-Module GroupPolicy -ErrorAction Stop
        Write-Success "GroupPolicy module loaded."
    } catch {
        Write-WarningMsg "GroupPolicy module not found. GPO checks will be limited."
    }
}

#endregion Configuration

#region Helper: Get AD parameters and domain info

function Get-ADQueryParams {
    $params = @{
        ErrorAction = 'Stop'
    }
    if ($Script:DcAddress) {
        $params.Server = $Script:DcAddress
    }
    if ($Script:AuthType -eq 'UserPass' -and $Script:Credential) {
        $params.Credential = $Script:Credential
    }
    return $params
}

function Initialize-ADContext {
    try {
        $Script:TotalChecks++
        $adParams = Get-ADQueryParams
        $Script:DomainObject = Get-ADDomain @adParams
        $rootDse            = Get-ADRootDSE @adParams
        $Script:BaseDN      = $rootDse.defaultNamingContext
        $Script:SuccessfulChecks++

        Write-Success ("AD Context: {0} ({1})" -f $Script:DomainObject.DNSRoot, $Script:BaseDN)
    } catch {
        $Script:FailedChecks++
        Write-ErrorMsg "Unable to initialize AD context: $_"
    }
}

#endregion Helper

#region PHASE 1 ‚Äì LDAP / AD Enumeration

function Invoke-LdapEnum {
    Write-Section "PHASE 1: LDAP / AD Enumeration"

    try {
        Import-Module ActiveDirectory -ErrorAction Stop
    } catch {
        Write-WarningMsg "ActiveDirectory module missing. Skipping LDAP phase."
        return
    }

    if (-not $Script:DomainObject -or -not $Script:BaseDN) {
        Initialize-ADContext
        if (-not $Script:DomainObject) {
            Write-ErrorMsg "No domain context. LDAP enumeration cannot continue."
            return
        }
    }

    $adParams = Get-ADQueryParams

    # 1. Domain info and functional levels
    try {
        $Script:TotalChecks++
        $dom = $Script:DomainObject
        Add-Finding -Level 'INFO' -Category 'Domain Info' -Message ("Domain: {0}, NetBIOS: {1}, Mode: {2}" -f $dom.DNSRoot, $dom.NetBIOSName, $dom.DomainMode)
        $Script:SuccessfulChecks++
    } catch {
        $Script:FailedChecks++
        Write-ErrorMsg "Error getting domain info: $_"
    }

    # 2. Password policy
    try {
        $Script:TotalChecks++
        $policy = Get-ADDefaultDomainPasswordPolicy @adParams
        $Script:SuccessfulChecks++

        if ($policy.MinPasswordLength -lt 12) {
            Add-Finding -Level 'MEDIUM' -Category 'Password Policy' `
                -Message ("Min password length = {0}" -f $policy.MinPasswordLength) `
                -Recommendation "Increase minimum length to at least 12 characters."
        } else {
            Add-Finding -Level 'INFO' -Category 'Password Policy' `
                -Message ("Min password length = {0}" -f $policy.MinPasswordLength)
        }

        if (-not $policy.ComplexityEnabled) {
            Add-Finding -Level 'HIGH' -Category 'Password Policy' `
                -Message "Password complexity is disabled." `
                -Recommendation "Enable complexity requirements."
        }

        if (-not $policy.LockoutThreshold -or $policy.LockoutThreshold -eq 0) {
            Add-Finding -Level 'MEDIUM' -Category 'Account Lockout' `
                -Message "No account lockout threshold configured." `
                -Recommendation "Configure lockout threshold to mitigate brute-force."
        }

    } catch {
        $Script:FailedChecks++
        Write-ErrorMsg "Error querying password policy: $_"
    }

    # 3. Domain Controllers
    try {
        $Script:TotalChecks++
        $dcs = Get-ADDomainController -Filter * @adParams
        $Script:SuccessfulChecks++

        $dcNames = $dcs.HostName -join ', '
        Add-Finding -Level 'INFO' -Category 'Domain Controllers' -Message ("DCs: {0}" -f $dcNames)
    } catch {
        $Script:FailedChecks++
        Write-ErrorMsg "Error enumerating Domain Controllers: $_"
    }

    # 4. Privileged groups
    $privGroups = @('Domain Admins','Enterprise Admins','Schema Admins','Administrators')
    foreach ($groupName in $privGroups) {
        try {
            $Script:TotalChecks++
            $group = Get-ADGroup -Identity $groupName @adParams
            $members = Get-ADGroupMember -Identity $group.DistinguishedName -Recursive @adParams |
                       Where-Object { $_.ObjectClass -eq 'user' }
            $Script:SuccessfulChecks++

            $memberNames = $members.SamAccountName | Sort-Object -Unique
            if ($memberNames.Count -gt 0) {
                Add-Finding -Level 'INFO' -Category 'Privileged Group' `
                    -Message ("{0}: {1}" -f $groupName, ($memberNames -join ', '))
            } else {
                Add-Finding -Level 'INFO' -Category 'Privileged Group' `
                    -Message ("{0}: no user members found" -f $groupName)
            }
        } catch {
            $Script:FailedChecks++
            Write-WarningMsg "Could not enumerate group '$groupName': $_"
        }
    }

    # 5. adminCount=1 vs Protected Users coverage
    try {
        $Script:TotalChecks++
        $allPriv = Get-ADUser -LDAPFilter '(adminCount=1)' -Properties adminCount, MemberOf @adParams
        $protGroup = Get-ADGroup -Identity 'Protected Users' @adParams
        $protMembers = @()
        if ($protGroup) {
            $protMembers = Get-ADGroupMember -Identity $protGroup.DistinguishedName -Recursive @adParams |
                           Where-Object { $_.ObjectClass -eq 'user' } |
                           Select-Object -ExpandProperty DistinguishedName
        }
        $Script:SuccessfulChecks++

        $privCount      = $allPriv.Count
        $protectedCount = 0

        if ($privCount -gt 0 -and $protMembers.Count -gt 0) {
            $protectedPriv = $allPriv | Where-Object { $protMembers -contains $_.DistinguishedName }
            $protectedCount = $protectedPriv.Count
        }

        if ($privCount -gt 0 -and $protectedCount -lt $privCount) {
            $unprotected = $privCount - $protectedCount
            Add-Finding -Level 'MEDIUM' -Category 'Protected Users' `
                -Message ("{0} privileged accounts are not in Protected Users" -f $unprotected) `
                -Recommendation "Consider adding high-privileged users to Protected Users to limit their exposure."
        } else {
            Add-Finding -Level 'INFO' -Category 'Protected Users' `
                -Message "Privileged accounts seem to be covered by Protected Users (or none found)."
        }

    } catch {
        $Script:FailedChecks++
        Write-ErrorMsg "Error evaluating Protected Users coverage: $_"
    }

    # 6. KRBTGT password age
    try {
        $Script:TotalChecks++
        $krbtgt = Get-ADUser -Identity 'krbtgt' -Properties PasswordLastSet @adParams
        if ($krbtgt -and $krbtgt.PasswordLastSet) {
            $daysOld = (New-TimeSpan -Start $krbtgt.PasswordLastSet -End (Get-Date)).Days
            $Script:SuccessfulChecks++

            if ($daysOld -gt 365) {
                Add-Finding -Level 'HIGH' -Category 'KRBTGT Password' `
                    -Message ("KRBTGT password age is {0} days" -f $daysOld) `
                    -Recommendation "Rotate KRBTGT password regularly (at least yearly; more often in high-risk environments)."
            } elseif ($daysOld -gt 180) {
                Add-Finding -Level 'MEDIUM' -Category 'KRBTGT Password' `
                    -Message ("KRBTGT password age is {0} days" -f $daysOld) `
                    -Recommendation "Plan a KRBTGT password rotation."
            } else {
                Add-Finding -Level 'INFO' -Category 'KRBTGT Password' `
                    -Message ("KRBTGT password age is {0} days" -f $daysOld)
            }
        } else {
            $Script:SuccessfulChecks++
            Add-Finding -Level 'INFO' -Category 'KRBTGT Password' -Message "KRBTGT account not found or no PasswordLastSet."
        }
    } catch {
        $Script:FailedChecks++
        Write-ErrorMsg "Error checking KRBTGT password age: $_"
    }

    # 7. Users with PasswordNeverExpires
    try {
        $Script:TotalChecks++
        $users = Get-ADUser -Filter * -Properties PasswordNeverExpires, Enabled, MemberOf @adParams
        $Script:SuccessfulChecks++

        $neverExp = $users | Where-Object { $_.PasswordNeverExpires -eq $true -and $_.Enabled -eq $true }
        if ($neverExp.Count -gt 0) {
            $names = ($neverExp | Select-Object -ExpandProperty SamAccountName) -join ', '
            Add-Finding -Level 'MEDIUM' -Category 'PasswordNeverExpires' `
                -Message ("{0} enabled accounts have PasswordNeverExpires set: {1}" -f $neverExp.Count, $names) `
                -Recommendation "Avoid PasswordNeverExpires for regular accounts; use dedicated service accounts with mitigations."
        } else {
            Add-Finding -Level 'INFO' -Category 'PasswordNeverExpires' -Message "No enabled accounts with PasswordNeverExpires were found."
        }
    } catch {
        $Script:FailedChecks++
        Write-ErrorMsg "Error enumerating PasswordNeverExpires accounts: $_"
    }
}

#endregion PHASE 1

#region PHASE 2 ‚Äì Kerberos Attack Surface (Config Only)

function Invoke-KerberosEnum {
    Write-Section "PHASE 2: Kerberos Attack Surface (Configuration)"

    try {
        Import-Module ActiveDirectory -ErrorAction Stop
    } catch {
        Write-WarningMsg "ActiveDirectory module missing. Skipping Kerberos phase."
        return
    }

    if (-not $Script:DomainObject -or -not $Script:BaseDN) {
        Initialize-ADContext
        if (-not $Script:DomainObject) { return }
    }

    $adParams = Get-ADQueryParams

    # 1. Kerberoastable accounts (just enumeration, no hash extraction)
    try {
        $Script:TotalChecks++
        $kerbUsers = Get-ADUser -Filter { ServicePrincipalName -like "*" } -Properties ServicePrincipalName, MemberOf, Enabled @adParams
        $Script:SuccessfulChecks++

        $count = $kerbUsers.Count
        if ($count -gt 0) {
            $names = ($kerbUsers | Select-Object -ExpandProperty SamAccountName) -join ', '
            Add-Finding -Level 'MEDIUM' -Category 'Kerberoasting Surface' `
                -Message ("{0} accounts have SPNs set (Kerberoastable): {1}" -f $count, $names) `
                -Recommendation "Use gMSA or strong random passwords for service accounts; avoid unnecessary SPNs."
        } else {
            Add-Finding -Level 'INFO' -Category 'Kerberoasting Surface' -Message "No accounts with SPNs found via AD cmdlets."
        }

        # privileged kerberoastable accounts
        $adminKerb = $kerbUsers | Where-Object {
            $_.MemberOf -match 'CN=Domain Admins' -or
            $_.MemberOf -match 'CN=Enterprise Admins' -or
            $_.MemberOf -match 'CN=Schema Admins'
        }

        if ($adminKerb.Count -gt 0) {
            $adminNames = ($adminKerb | Select-Object -ExpandProperty SamAccountName) -join ', '
            Add-Finding -Level 'CRITICAL' -Category 'Kerberoasting Surface' `
                -Message ("{0} PRIVILEGED kerberoastable accounts detected: {1}" -f $adminKerb.Count, $adminNames) `
                -Recommendation "Remove SPNs from privileged users or migrate services to gMSA with long random passwords."
        }

    } catch {
        $Script:FailedChecks++
        Write-ErrorMsg "Error enumerating Kerberoastable accounts: $_"
    }

    # 2. AS-REP roastable accounts (DoesNotRequirePreAuth)
    try {
        $Script:TotalChecks++
        $asrepUsers = Get-ADUser -LDAPFilter '(userAccountControl:1.2.840.113556.1.4.803:=4194304)' `
                                  -Properties userAccountControl, MemberOf, Enabled @adParams
        $Script:SuccessfulChecks++

        if ($asrepUsers.Count -gt 0) {
            $names = ($asrepUsers | Select-Object -ExpandProperty SamAccountName) -join ', '
            Add-Finding -Level 'HIGH' -Category 'AS-REP Roast Surface' `
                -Message ("{0} accounts do not require Kerberos pre-authentication: {1}" -f $asrepUsers.Count, $names) `
                -Recommendation "Disable 'Does not require Kerberos pre-authentication' unless strictly required."
        } else {
            Add-Finding -Level 'INFO' -Category 'AS-REP Roast Surface' -Message "No AS-REP roastable accounts found via AD cmdlets."
        }
    } catch {
        $Script:FailedChecks++
        Write-ErrorMsg "Error enumerating AS-REP roastable accounts: $_"
    }
}

#endregion PHASE 2

#region PHASE 3 ‚Äì ADCS / Certificate Services

function Invoke-ADCsEnum {
    Write-Section "PHASE 3: AD CS (Certificate Services) Enumeration"

    try {
        Import-Module ActiveDirectory -ErrorAction Stop
    } catch {
        Write-WarningMsg "ActiveDirectory module missing. Skipping ADCS phase."
        return
    }

    if (-not $Script:DomainObject -or -not $Script:BaseDN) {
        Initialize-ADContext
        if (-not $Script:DomainObject) { return }
    }

    $adParams = Get-ADQueryParams

    # ADCS enrollment services
    try {
        $Script:TotalChecks++
        $configNC = (Get-ADRootDSE @adParams).configurationNamingContext
        $caServers = Get-ADObject -LDAPFilter '(objectClass=pKIEnrollmentService)' `
                                  -SearchBase $configNC `
                                  -Properties dNSHostName, cn, flags @adParams
        $Script:SuccessfulChecks++

        if ($caServers.Count -gt 0) {
            $list = $caServers | ForEach-Object {
                "{0} ({1})" -f $_.cn, $_.dNSHostName
            }
            Add-Finding -Level 'INFO' -Category 'ADCS Enrollment Services' `
                -Message ("CA servers: {0}" -f ($list -join '; '))
        } else {
            Add-Finding -Level 'INFO' -Category 'ADCS Enrollment Services' `
                -Message "No AD CS enrollment services found in Configuration NC."
        }
    } catch {
        $Script:FailedChecks++
        Write-ErrorMsg "Error enumerating ADCS Enrollment Services: $_"
    }

    # Certificate templates (lightweight)
    if (-not $Script:QuickMode) {
        try {
            $Script:TotalChecks++
            $configNC = (Get-ADRootDSE @adParams).configurationNamingContext
            $templates = Get-ADObject -LDAPFilter '(objectClass=pKICertificateTemplate)' `
                                      -SearchBase $configNC `
                                      -Properties displayName, msPKI-Enrollment-Flag, msPKI-RA-Signature, msPKI-Certificate-Name-Flag @adParams
            $Script:SuccessfulChecks++

            $templateNames = $templates.displayName
            Add-Finding -Level 'INFO' -Category 'ADCS Templates' `
                -Message ("Found {0} certificate templates: {1}" -f $templates.Count, ($templateNames -join ', '))

            # Very generic heuristic: templates with client auth usage but no RA-signature requirement
            $risky = $templates | Where-Object {
                # don't attempt full bit-decoding, just flag for manual review
                $_.'msPKI-RA-Signature' -eq $null
            }

            if ($risky.Count -gt 0) {
                $riskyNames = $risky.displayName -join ', '
                Add-Finding -Level 'MEDIUM' -Category 'ADCS Templates' `
                    -Message ("{0} certificate templates have no RA-signature requirement: {1}" -f $risky.Count, $riskyNames) `
                    -Recommendation "Manually review templates for enrollment/issuance restrictions and privilege escalation paths."
            }

        } catch {
            $Script:FailedChecks++
            Write-ErrorMsg "Error enumerating certificate templates: $_"
        }
    }
    else {
        Write-Info "Quick mode: skipping deep template enumeration."
    }
}

#endregion PHASE 3

#region PHASE 4 ‚Äì Delegation

function Invoke-DelegationEnum {
    Write-Section "PHASE 4: Delegation Configuration"

    try {
        Import-Module ActiveDirectory -ErrorAction Stop
    } catch {
        Write-WarningMsg "ActiveDirectory module missing. Skipping Delegation phase."
        return
    }

    if (-not $Script:DomainObject -or -not $Script:BaseDN) {
        Initialize-ADContext
        if (-not $Script:DomainObject) { return }
    }

    $adParams = Get-ADQueryParams

    # Unconstrained delegation (TRUSTED_FOR_DELEGATION)
    try {
        $Script:TotalChecks++
        $unconstrainedComputers = Get-ADComputer -LDAPFilter '(userAccountControl:1.2.840.113556.1.4.803:=524288)' `
                                                 -Properties userAccountControl, dNSHostName @adParams
        $Script:SuccessfulChecks++

        if ($unconstrainedComputers.Count -gt 0) {
            $names = $unconstrainedComputers.dNSHostName -join ', '
            Add-Finding -Level 'HIGH' -Category 'Unconstrained Delegation' `
                -Message ("Computers with unconstrained delegation: {0}" -f $names) `
                -Recommendation "Avoid unconstrained delegation; migrate to constrained or resource-based constrained delegation."
        } else {
            Add-Finding -Level 'INFO' -Category 'Unconstrained Delegation' -Message "No unconstrained delegation computers found."
        }
    } catch {
        $Script:FailedChecks++
        Write-ErrorMsg "Error enumerating unconstrained delegation: $_"
    }

    # Constrained delegation (msDS-AllowedToDelegateTo)
    try {
        $Script:TotalChecks++
        $constrained = Get-ADObject -LDAPFilter '(msDS-AllowedToDelegateTo=*)' `
                                    -SearchBase $Script:BaseDN `
                                    -Properties msDS-AllowedToDelegateTo, samAccountName, objectClass @adParams
        $Script:SuccessfulChecks++

        if ($constrained.Count -gt 0) {
            $entries = $constrained | ForEach-Object {
                "{0} ({1}) -> {2}" -f $_.samAccountName, $_.ObjectClass, (($_.'msDS-AllowedToDelegateTo') -join ',')
            }
            Add-Finding -Level 'MEDIUM' -Category 'Constrained Delegation' `
                -Message ("Objects with constrained delegation configured: {0}" -f ($entries -join ' ; ')) `
                -Recommendation "Verify constrained delegation targets follow least-privilege and are necessary."
        } else {
            Add-Finding -Level 'INFO' -Category 'Constrained Delegation' -Message "No constrained delegation configurations found."
        }
    } catch {
        $Script:FailedChecks++
        Write-ErrorMsg "Error enumerating constrained delegation: $_"
    }

    # Resource-based constrained delegation (RBCD)
    try {
        $Script:TotalChecks++
        $rbcd = Get-ADObject -LDAPFilter '(msDS-AllowedToActOnBehalfOfOtherIdentity=*)' `
                             -SearchBase $Script:BaseDN `
                             -Properties msDS-AllowedToActOnBehalfOfOtherIdentity, samAccountName, objectClass @adParams
        $Script:SuccessfulChecks++

        if ($rbcd.Count -gt 0) {
            $names = $rbcd.samAccountName -join ', '
            Add-Finding -Level 'MEDIUM' -Category 'RBCD' `
                -Message ("Objects with RBCD configured (msDS-AllowedToActOnBehalfOfOtherIdentity): {0}" -f $names) `
                -Recommendation "Carefully validate RBCD entries; misconfigurations may enable privilege escalation."
        } else {
            Add-Finding -Level 'INFO' -Category 'RBCD' -Message "No RBCD configurations found."
        }
    } catch {
        $Script:FailedChecks++
        Write-ErrorMsg "Error enumerating RBCD: $_"
    }
}

#endregion PHASE 4

#region PHASE 5 ‚Äì GPO & SYSVOL

function Invoke-GpoEnum {
    Write-Section "PHASE 5: GPO & SYSVOL Enumeration"

    $gpoModuleLoaded = $true
    try {
        Import-Module GroupPolicy -ErrorAction Stop
    } catch {
        $gpoModuleLoaded = $false
        Write-WarningMsg "GroupPolicy module missing; GPO checks limited."
    }

    if (-not $Script:DomainName) {
        Write-WarningMsg "DomainName not set; skipping SYSVOL checks."
    }

    # GPO summary
    if ($gpoModuleLoaded) {
        try {
            $Script:TotalChecks++
            $allGpo = Get-GPO -All
            $Script:SuccessfulChecks++

            Add-Finding -Level 'INFO' -Category 'GPO Summary' `
                -Message ("Total GPOs: {0}" -f $allGpo.Count)

            if (-not $Script:QuickMode) {
                # Look for GPOs with scripts settings (high-level)
                $scriptGpos = @()
                foreach ($g in $allGpo) {
                    try {
                        $reportXml = Get-GPOReport -Guid $g.Id -ReportType Xml
                        if ($reportXml -match "<Scripts") {
                            $scriptGpos += $g.DisplayName
                        }
                    } catch { }
                }

                if ($scriptGpos.Count -gt 0) {
                    Add-Finding -Level 'MEDIUM' -Category 'GPO Scripts' `
                        -Message ("GPOs with script settings: {0}" -f ($scriptGpos -join ', ')) `
                        -Recommendation "Review scripts for hard-coded credentials or unsafe actions."
                }
            }
        } catch {
            $Script:FailedChecks++
            Write-ErrorMsg "Error enumerating GPOs: $_"
        }
    }

    # SYSVOL basic scan for cpassword (without decryption)
    if ($Script:DomainName -and -not $Script:QuickMode) {
        try {
            $Script:TotalChecks++
            $sysvolPath = "\\$($Script:DomainName)\SYSVOL"
            if (Test-Path $sysvolPath) {
                $xmlFiles = Get-ChildItem -Path $sysvolPath -Recurse -Filter *.xml -ErrorAction SilentlyContinue
                $hits     = @()
                foreach ($file in $xmlFiles) {
                    try {
                        $content = Get-Content -Path $file.FullName -ErrorAction SilentlyContinue
                        if ($content -match "cpassword") {
                            $hits += $file.FullName
                        }
                    } catch { }
                }

                $Script:SuccessfulChecks++
                if ($hits.Count -gt 0) {
                    Add-Finding -Level 'HIGH' -Category 'GPP Credentials' `
                        -Message ("Files in SYSVOL contain 'cpassword' values: {0}" -f ($hits -join '; ')) `
                        -Recommendation "Remove Group Policy Preferences credentials and rotate any exposed passwords."
                } else {
                    Add-Finding -Level 'INFO' -Category 'GPP Credentials' -Message "No SYSVOL files with 'cpassword' detected in this scan."
                }
            } else {
                $Script:SuccessfulChecks++
                Write-WarningMsg "SYSVOL path not accessible: $sysvolPath"
            }
        } catch {
            $Script:FailedChecks++
            Write-ErrorMsg "Error scanning SYSVOL for GPP cpassword: $_"
        }
    } elseif ($Script:QuickMode) {
        Write-Info "Quick mode: skipping deep SYSVOL scan."
    }
}

#endregion PHASE 5

#region PHASE 6 ‚Äì ACL / Object Permissions (High-Level)

function Invoke-AclEnum {
    Write-Section "PHASE 6: ACL / Object Permissions (High-Level)"

    try {
        Import-Module ActiveDirectory -ErrorAction Stop
    } catch {
        Write-WarningMsg "ActiveDirectory module missing. Skipping ACL phase."
        return
    }

    if (-not $Script:DomainObject -or -not $Script:BaseDN) {
        Initialize-ADContext
        if (-not $Script:DomainObject) { return }
    }

    $adParams = Get-ADQueryParams

    # Domain root ACL
    try {
        $Script:TotalChecks++
        $domainDN = $Script:DomainObject.DistinguishedName
        $aclPath  = "AD:\$domainDN"
        $acl      = Get-Acl -Path $aclPath
        $Script:SuccessfulChecks++

        $nonAdminDangerous = $acl.Access | Where-Object {
            ($_.ActiveDirectoryRights -match 'GenericAll|WriteOwner|WriteDacl|ExtendedRight') -and
            ($_.IdentityReference -notmatch 'Admins|SYSTEM|Enterprise Admins|Domain Admins')
        }

        if ($nonAdminDangerous) {
            $entries = $nonAdminDangerous | ForEach-Object {
                "{0} -> {1}" -f $_.IdentityReference, $_.ActiveDirectoryRights
            }
            Add-Finding -Level 'HIGH' -Category 'Domain ACL' `
                -Message ("Non-admin principals with high privileges on domain root: {0}" -f ($entries -join ' ; ')) `
                -Recommendation "Review and tighten ACLs on the domain root; limit GenericAll/WriteDacl/ExtendedRight to admins."
        } else {
            Add-Finding -Level 'INFO' -Category 'Domain ACL' -Message "No obvious non-admin high-privilege ACEs on domain root (quick check)."
        }
    } catch {
        $Script:FailedChecks++
        Write-ErrorMsg "Error analyzing domain root ACL: $_"
    }

    # Optional: sample OU ACLs (just a few for quick mode)
    if (-not $Script:QuickMode) {
        try {
            $Script:TotalChecks++
            $ous = Get-ADOrganizationalUnit -Filter * -SearchBase $Script:BaseDN -ResultSetSize 5 @adParams
            $Script:SuccessfulChecks++

            foreach ($ou in $ous) {
                try {
                    $ouAcl = Get-Acl -Path ("AD:\{0}" -f $ou.DistinguishedName)
                    $nonAdmin = $ouAcl.Access | Where-Object {
                        ($_.ActiveDirectoryRights -match 'GenericAll|WriteOwner|WriteDacl|ExtendedRight') -and
                        ($_.IdentityReference -notmatch 'Admins|SYSTEM|Enterprise Admins|Domain Admins')
                    }
                    if ($nonAdmin) {
                        $entries = $nonAdmin | ForEach-Object {
                            "{0} -> {1}" -f $_.IdentityReference, $_.ActiveDirectoryRights
                        }
                        Add-Finding -Level 'MEDIUM' -Category 'OU ACL' `
                            -Message ("OU {0} has non-admin high-privilege ACEs: {1}" -f $ou.Name, ($entries -join ' ; ')) `
                            -Recommendation "Review ACLs on this OU; potential path for privilege escalation."
                    }
                } catch { }
            }
        } catch {
            $Script:FailedChecks++
            Write-ErrorMsg "Error sampling OU ACLs: $_"
        }
    } else {
        Write-Info "Quick mode: skipping OU ACL sampling."
    }
}

#endregion PHASE 6

#region PHASE 7 ‚Äì Share & File System Enumeration (Local Host)

function Invoke-ShareEnum {
    Write-Section "PHASE 7: Share & File System Enumeration (Local)"

    # Local SMB shares
    try {
        $Script:TotalChecks++
        $shares = Get-SmbShare -ErrorAction Stop
        $Script:SuccessfulChecks++

        $shareInfos = $shares | ForEach-Object {
            "{0} ({1})" -f $_.Name, $_.Path
        }
        Add-Finding -Level 'INFO' -Category 'Local Shares' `
            -Message ("Local SMB shares: {0}" -f ($shareInfos -join ' ; '))

        foreach ($share in $shares) {
            try {
                $access = Get-SmbShareAccess -Name $share.Name -ErrorAction Stop
                $danger = $access | Where-Object {
                    ($_.Name -match 'Everyone|Authenticated Users') -and
                    ($_.AccessRight -match 'Change|Full')
                }
                if ($danger) {
                    $principals = $danger.Name -join ', '
                    Add-Finding -Level 'HIGH' -Category 'Share Permissions' `
                        -Message ("Share {0} grants {1} write-like access." -f $share.Name, $principals) `
                        -Recommendation "Restrict share permissions; avoid write access for Everyone/Authenticated Users."
                }
            } catch { }
        }
    } catch {
        $Script:FailedChecks++
        Write-ErrorMsg "Error enumerating local SMB shares: $_"
    }

    # Quick search for world-writable directories under common paths (very high-level)
    if (-not $Script:QuickMode) {
        $paths = @('C:\ProgramData','C:\Temp','C:\Users\Public')
        foreach ($p in $paths) {
            if (Test-Path $p) {
                try {
                    $Script:TotalChecks++
                    $acl = Get-Acl -Path $p
                    $Script:SuccessfulChecks++

                    $worldWrite = $acl.Access | Where-Object {
                        $_.IdentityReference -match 'Everyone|Authenticated Users' -and
                        $_.FileSystemRights -match 'Write|Modify|FullControl'
                    }
                    if ($worldWrite) {
                        Add-Finding -Level 'MEDIUM' -Category 'World-Writable Path' `
                            -Message ("{0} has write permissions for broad groups." -f $p) `
                            -Recommendation "Review permissions on public/temp folders and restrict where possible."
                    }
                } catch {
                    $Script:FailedChecks++
                    Write-ErrorMsg "Error checking ACL on $p: $_"
                }
            }
        }
    } else {
        Write-Info "Quick mode: skipping world-writable folder checks."
    }
}

#endregion PHASE 7

#region PHASE 8 ‚Äì Credential Hunting (Non-exploitative)

function Invoke-CredentialHunt {
    Write-Section "PHASE 8: Credential Hunting (Indicators Only)"

    # 1. Search for "password=" in simple config locations (limited scope)
    $paths = @(
        "C:\Scripts",
        "C:\ProgramData",
        "$env:SystemRoot\System32\inetsrv\config"
    )

    foreach ($p in $paths) {
        if (Test-Path $p) {
            try {
                $Script:TotalChecks++
                $files = Get-ChildItem -Path $p -Recurse -File -Include *.config,*.xml,*.ini,*.txt -ErrorAction SilentlyContinue
                $hits = @()
                foreach ($f in $files) {
                    try {
                        if (Select-String -Path $f.FullName -Pattern 'password=' -SimpleMatch -Quiet) {
                            $hits += $f.FullName
                        }
                    } catch { }
                }
                $Script:SuccessfulChecks++

                if ($hits.Count -gt 0) {
                    Add-Finding -Level 'MEDIUM' -Category 'Config Credentials' `
                        -Message ("Possible cleartext or weakly protected credentials in files under {0}: {1}" -f $p, ($hits -join '; ')) `
                        -Recommendation "Review these files and remove or securely store credentials (e.g. using a vault)."
                }
            } catch {
                $Script:FailedChecks++
                Write-ErrorMsg "Error scanning $p for password patterns: $_"
            }
        }
    }

    # 2. Scheduled tasks with embedded credentials (we just list, not extract)
    try {
        $Script:TotalChecks++
        $tasks = Get-ScheduledTask -ErrorAction Stop
        $Script:SuccessfulChecks++

        $tasksWithCreds = $tasks | Where-Object {
            $_.Principal.LogonType -in @('Password','S4U')
        }

        if ($tasksWithCreds.Count -gt 0) {
            $names = $tasksWithCreds.TaskName -join ', '
            Add-Finding -Level 'MEDIUM' -Category 'Scheduled Tasks' `
                -Message ("Tasks using Password/S4U logon types: {0}" -f $names) `
                -Recommendation "Review scheduled tasks; avoid embedding passwords and use service accounts with least privilege."
        } else {
            Add-Finding -Level 'INFO' -Category 'Scheduled Tasks' -Message "No tasks using Password/S4U logon types detected."
        }

    } catch {
        $Script:FailedChecks++
        Write-ErrorMsg "Error enumerating scheduled tasks: $_"
    }
}

#endregion PHASE 8

#region PHASE 9 ‚Äì Session Enumeration (Local)

function Invoke-SessionEnum {
    Write-Section "PHASE 9: Session Enumeration (Local Host)"

    # Logged-on users via Win32_LoggedOnUser (local machine only)
    try {
        $Script:TotalChecks++
        $sessions = Get-CimInstance -ClassName Win32_LoggedOnUser -ErrorAction Stop
        $Script:SuccessfulChecks++

        $userAccounts = $sessions | ForEach-Object {
            $_.Antecedent -match 'Domain="([^"]+)",Name="([^"]+)"' | Out-Null
            if ($matches.Count -gt 0) {
                "{0}\{1}" -f $matches[1], $matches[2]
            }
        } | Sort-Object -Unique

        if ($userAccounts.Count -gt 0) {
            Add-Finding -Level 'INFO' -Category 'Local Sessions' `
                -Message ("Users currently logged on (local): {0}" -f ($userAccounts -join ', '))
        } else {
            Add-Finding -Level 'INFO' -Category 'Local Sessions' -Message "No interactive sessions detected via Win32_LoggedOnUser."
        }

    } catch {
        $Script:FailedChecks++
        Write-ErrorMsg "Error enumerating local sessions: $_"
    }
}

#endregion PHASE 9

#region PHASE 10 ‚Äì Trusts

function Invoke-TrustEnum {
    Write-Section "PHASE 10: Domain & Forest Trusts"

    try {
        Import-Module ActiveDirectory -ErrorAction Stop
    } catch {
        Write-WarningMsg "ActiveDirectory module missing. Skipping Trusts phase."
        return
    }

    if (-not $Script:DomainObject -or -not $Script:BaseDN) {
        Initialize-ADContext
        if (-not $Script:DomainObject) { return }
    }

    $adParams = Get-ADQueryParams

    try {
        $Script:TotalChecks++
        $trusts = Get-ADTrust -Filter * @adParams
        $Script:SuccessfulChecks++

        if ($trusts.Count -gt 0) {
            $entries = $trusts | ForEach-Object {
                "{0} -> {1} ({2}, {3})" -f $_.Source, $_.Target, $_.TrustType, $_.TrustDirection
            }
            Add-Finding -Level 'INFO' -Category 'Domain Trusts' `
                -Message ("Trust relationships: {0}" -f ($entries -join ' ; '))
        } else {
            Add-Finding -Level 'INFO' -Category 'Domain Trusts' -Message "No AD trust relationships detected by Get-ADTrust."
        }
    } catch {
        $Script:FailedChecks++
        Write-ErrorMsg "Error querying AD trust relationships: $_"
    }
}

#endregion PHASE 10

#region PHASE 11 ‚Äì Infrastructure & Services

function Invoke-InfrastructureEnum {
    Write-Section "PHASE 11: Infrastructure & Services (Local) "

    # DNS client/server settings (local)
    try {
        $Script:TotalChecks++
        $dnsClient = Get-DnsClientServerAddress -AddressFamily IPv4 -ErrorAction Stop
        $Script:SuccessfulChecks++

        $entries = $dnsClient | ForEach-Object {
            "{0}: {1}" -f $_.InterfaceAlias, (($_.ServerAddresses) -join ', ')
        }
        Add-Finding -Level 'INFO' -Category 'DNS Client' `
            -Message ("Local DNS server addresses: {0}" -f ($entries -join ' ; '))
    } catch {
        $Script:FailedChecks++
        Write-ErrorMsg "Error enumerating DNS client: $_"
    }

    # Check if Windows firewall is enabled (basic)
    try {
        $Script:TotalChecks++
        $profiles = Get-NetFirewallProfile -ErrorAction Stop
        $Script:SuccessfulChecks++

        $disabled = $profiles | Where-Object { -not $_.Enabled }
        if ($disabled.Count -gt 0) {
            $names = $disabled.Name -join ', '
            Add-Finding -Level 'MEDIUM' -Category 'Windows Firewall' `
                -Message ("Firewall disabled for profiles: {0}" -f $names) `
                -Recommendation "Enable firewall profiles and configure rules according to security policy."
        } else {
            Add-Finding -Level 'INFO' -Category 'Windows Firewall' -Message "Windows Firewall enabled for all profiles."
        }
    } catch {
        $Script:FailedChecks++
        Write-ErrorMsg "Error checking firewall configuration: $_"
    }
}

#endregion PHASE 11

#region PHASE 12 ‚Äì BloodHound Collection (Preparation Only)

function Invoke-BloodHoundCollection {
    Write-Section "PHASE 12: BloodHound Collection (Preparation Only)"

    # For safety, we don't invoke SharpHound / bloodhound collectors directly.
    # Instead, we create a directory and guidance text for manual use.

    try {
        $Script:TotalChecks++
        $bhDir = Join-Path $Script:OutputRoot 'bloodhound'
        if (-not (Test-Path $bhDir)) {
            New-Item -ItemType Directory -Path $bhDir -Force | Out-Null
        }

        $note = @"
BloodHound collection is not automated in this script for safety reasons.

Recommended manual approach (example, adjust to your environment & tooling):

  1. Run SharpHound or equivalent collector with an appropriate, authorized account.
  2. Save the resulting .zip files into:
       $bhDir
  3. Import into BloodHound / BloodHound CE for path analysis.
"@
        $notePath = Join-Path $bhDir 'README_BloodHound_Collection.txt'
        $note | Out-File -FilePath $notePath -Encoding UTF8 -Force

        $Script:SuccessfulChecks++
        Add-Finding -Level 'INFO' -Category 'BloodHound Prep' `
            -Message "Created BloodHound output folder and README with manual collection guidance." `
            -Recommendation "Use dedicated AD collectors (SharpHound, AzureHound, etc.) and import into BloodHound."
    } catch {
        $Script:FailedChecks++
        Write-ErrorMsg "Error preparing BloodHound directory: $_"
    }
}

#endregion PHASE 12

#region PHASE 13 ‚Äì Enhanced Security Controls

function Invoke-EnhancedSecurityChecks {
    Write-Section "PHASE 13: Enhanced Security Controls"

    try {
        Import-Module ActiveDirectory -ErrorAction Stop
    } catch {
        Write-WarningMsg "ActiveDirectory module missing. Skipping AD-specific enhanced checks."
    }

    $adParams = Get-ADQueryParams

    # LAPS (ms-Mcs-AdmPwd) usage
    if ($Script:DomainName -and $Script:BaseDN) {
        try {
            $Script:TotalChecks++
            $lapsObjects = Get-ADObject -LDAPFilter '(ms-Mcs-AdmPwdExpirationTime=*)' `
                                        -SearchBase $Script:BaseDN `
                                        -Properties ms-Mcs-AdmPwdExpirationTime @adParams
            $Script:SuccessfulChecks++

            if ($lapsObjects.Count -gt 0) {
                Add-Finding -Level 'INFO' -Category 'LAPS' `
                    -Message ("LAPS seems to be in use; objects with AdmPwdExpirationTime: {0}" -f $lapsObjects.Count) `
                    -Recommendation "Ensure LAPS ACLs are restricted to appropriate admin groups."
            } else {
                Add-Finding -Level 'MEDIUM' -Category 'LAPS' `
                    -Message "No evidence of LAPS (Local Administrator Password Solution) usage found." `
                    -Recommendation "Consider deploying LAPS to randomize local admin passwords."
            }
        } catch {
            $Script:FailedChecks++
            Write-ErrorMsg "Error checking for LAPS usage: $_"
        }
    }

    # SMB signing for local host
    try {
        $Script:TotalChecks++
        $regPath = 'HKLM:\SYSTEM\CurrentControlSet\Services\LanmanServer\Parameters'
        $smbSigningRequired = (Get-ItemProperty -Path $regPath -Name 'RequireSecuritySignature' -ErrorAction SilentlyContinue).RequireSecuritySignature
        $Script:SuccessfulChecks++

        if ($smbSigningRequired -eq 1) {
            Add-Finding -Level 'INFO' -Category 'SMB Signing' -Message "SMB signing is required on the local server."
        } else {
            Add-Finding -Level 'MEDIUM' -Category 'SMB Signing' `
                -Message "SMB signing is not required on the local server." `
                -Recommendation "Enable SMB signing to mitigate relay attacks (depending on performance requirements)."
        }
    } catch {
        $Script:FailedChecks++
        Write-ErrorMsg "Error checking SMB signing configuration: $_"
    }
}

#endregion PHASE 13

#region PHASE 14 ‚Äì LOLBins & Persistence Indicators

function Invoke-LolBinsPersistenceEnum {
    Write-Section "PHASE 14: LOLBins & Persistence Indicators (Local)"

    # Startup folder items
    try {
        $Script:TotalChecks++
        $startupPaths = @(
            "$env:ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp",
            "$env:AppData\Microsoft\Windows\Start Menu\Programs\Startup"
        )
        $Script:SuccessfulChecks++

        foreach ($p in $startupPaths) {
            if (Test-Path $p) {
                $items = Get-ChildItem -Path $p -ErrorAction SilentlyContinue
                if ($items.Count -gt 0) {
                    $names = $items.Name -join ', '
                    Add-Finding -Level 'INFO' -Category 'Startup Items' `
                        -Message ("Items in startup folder {0}: {1}" -f $p, $names) `
                        -Recommendation "Ensure all startup items are expected and trusted."
                }
            }
        }
    } catch {
        $Script:FailedChecks++
        Write-ErrorMsg "Error checking startup folders: $_"
    }

    # Common Run / RunOnce keys (high-level)
    $runKeys = @(
        'HKLM:\Software\Microsoft\Windows\CurrentVersion\Run',
        'HKCU:\Software\Microsoft\Windows\CurrentVersion\Run'
    )

    foreach ($rk in $runKeys) {
        try {
            $Script:TotalChecks++
            if (Test-Path $rk) {
                $values = Get-ItemProperty -Path $rk -ErrorAction SilentlyContinue
                $Script:SuccessfulChecks++

                $props = $values.PSObject.Properties | Where-Object { $_.Name -ne 'PSPath' -and $_.Name -ne 'PSParentPath' -and $_.Name -ne 'PSChildName' -and $_.Name -ne 'PSDrive' -and $_.Name -ne 'PSProvider' }
                if ($props.Count -gt 0) {
                    $list = $props | ForEach-Object { "{0} = {1}" -f $_.Name, $_.Value }
                    Add-Finding -Level 'INFO' -Category 'Run Keys' `
                        -Message ("Startup Run entries in {0}: {1}" -f $rk, ($list -join ' ; ')) `
                        -Recommendation "Validate these Run entries; remove unknown or untrusted entries."
                }
            } else {
                $Script:SuccessfulChecks++
            }
        } catch {
            $Script:FailedChecks++
            Write-ErrorMsg "Error reading Run key $rk: $_"
        }
    }
}

#endregion PHASE 14

#region Reporting

function Generate-Reports {
    Write-Section "Report Generation"

    $reportDir = Join-Path $Script:OutputRoot 'reports'
    if (-not (Test-Path $reportDir)) {
        New-Item -ItemType Directory -Path $reportDir -Force | Out-Null
    }

    $csvPath  = Join-Path $reportDir 'Findings.csv'
    $txtPath  = Join-Path $reportDir 'Findings.txt'

    $Script:Findings | Export-Csv -Path $csvPath -NoTypeInformation -Encoding UTF8

    $Script:Findings | ForEach-Object {
        "[{0}] {1}: {2}`nRecommendation: {3}`n" -f $_.Level, $_.Category, $_.Message, $_.Recommendation
    } | Out-File -FilePath $txtPath -Encoding UTF8

    Write-Success "Findings CSV : $csvPath"
    Write-Success "Findings TXT : $txtPath"
}

function Show-FinalSummary {
    $end = Get-Date
    $duration = $end - $Script:StartTime

    Write-Host ""
    Write-Host "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó" -ForegroundColor Green
    Write-Host "‚ïë                    ASSESSMENT COMPLETE                               ‚ïë" -ForegroundColor Green
    Write-Host "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù" -ForegroundColor Green
    Write-Host ""

    Write-Host ("Duration           : {0:hh\:mm\:ss}" -f $duration) -ForegroundColor Cyan
    Write-Host ("Total Checks       : {0}" -f $Script:TotalChecks) -ForegroundColor Cyan
    Write-Host ("Successful Checks  : {0}" -f $Script:SuccessfulChecks) -ForegroundColor Cyan
    Write-Host ("Failed Checks      : {0}" -f $Script:FailedChecks) -ForegroundColor Cyan
    Write-Host ""
    Write-Host "Findings: " -ForegroundColor Cyan
    Write-Host ("  CRITICAL : {0}" -f $Script:CriticalFindings) -ForegroundColor Red
    Write-Host ("  HIGH     : {0}" -f $Script:HighFindings) -ForegroundColor Yellow
    Write-Host ("  MEDIUM   : {0}" -f $Script:MediumFindings) -ForegroundColor Magenta
    Write-Host ("  INFO     : {0}" -f $Script:InfoFindings) -ForegroundColor Gray
    Write-Host ""

    if ($Script:CriticalFindings -gt 0 -or $Script:HighFindings -gt 0) {
        Write-Host "‚ö†Ô∏è  CRITICAL/HIGH findings detected. Prioritize remediation." -ForegroundColor Red
    } else {
        Write-Host "‚úÖ No CRITICAL/HIGH findings recorded by this run." -ForegroundColor Green
    }

    Write-Host ""
    Write-Host "Reports saved under: $($Script:OutputRoot)\reports" -ForegroundColor Green
    Write-Host ""
}

#endregion Reporting

#region Main Flow

if ($Help) {
    Show-Help
    return
}

if ($Version) {
    Write-Host "Ultimate-ADEnum PowerShell Version: $($Script:VERSION)"
    return
}

$Script:NonInteractive = [bool]$NonInteractive

Show-Banner
Check-Dependencies
Configure-Authentication
Configure-Scope
Initialize-Output
Initialize-ADContext

if (-not (Prompt-YesNo -Prompt "Start enumeration?" -Default $true)) {
    Write-WarningMsg "Assessment cancelled by user."
    return
}

Set-Location $Script:OutputRoot
Write-Success "Starting Ultimate AD Enumeration & Security Audit..."

Invoke-LdapEnum
Invoke-KerberosEnum
Invoke-ADCsEnum
Invoke-DelegationEnum
Invoke-GpoEnum
Invoke-AclEnum
Invoke-ShareEnum
Invoke-CredentialHunt
Invoke-SessionEnum
Invoke-TrustEnum
Invoke-InfrastructureEnum
Invoke-BloodHoundCollection
Invoke-EnhancedSecurityChecks
Invoke-LolBinsPersistenceEnum

Generate-Reports
Show-FinalSummary

#endregion Main Flow
